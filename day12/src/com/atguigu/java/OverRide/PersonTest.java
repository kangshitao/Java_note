package com.atguigu.java.OverRide;

/**
 * @author Kangshitao
 * @date 2021年3月18日 上午11:09
 */

/*
一、方法重写（override/overwrite）
1.重写：子类继承父类以后，可以对父类中同名同参数的方法，进行覆盖操作
2.应用：重写以后，子类对象调用此同名同参方法时，实际执行的是子类重写的方法。
3.重写的规定：
    方法的声明： 权限修饰符 返回值类型 方法名（参数列表）｛
                                  //方法体。
                           ｝
     ①子类重写的方法的方法名和形参列表，与父类被重写的方法的方法名和形参列表相同
     ②重写方法的权限不小于父类被重写的方法。
        >特殊情况，子类不能重写父类中private的方法
     ③返回值类型：
        >如果父类方法返回值类型是void，则子类重写方法的返回值必须是void
        >如果父类方法返回值类型是A类，则子类重写方法的返回值可以是A类，或是A类的子类。
        >如果父类方法返回值类型是基本数据类型，则子类重写的返回值类型必须是相同的基本数据类型
     ④子类重写的方法抛出的异常类型，不大于父类被重写方法的抛出的异常类型

***子类和父类中同名同参数的方法，要么都是非static（考虑重写），要么都是static（不是重写）。

区分方法的重载和重写的区别：
>重写：类名、方法名相同，参数列表相同。表现为多态性。运行时才确定要调用的方法，称为“晚绑定”或“动态绑定”。
>重载：类名、方法名相同，参数列表不同。不表现为多态性。 重载方法的调用地址在编译期就绑定了，称为“早绑定”或“静态绑定”



二、super关键字
1.super理解为：父类的
2.super可以用来调用：属性、方法、构造器
3.super调用属性和方法：
    3.1可以在子类的方法或构造器中，通过“super.属性”或“super.方法”的方式，
    显式地调用父类中声明的属性或方法。但通常情况下省略"super."
    3.2特殊情况，当子类和父类中定义了同名的属性时，如果想在子类中调用父类中声明的属性，
    必须使用"super.属性"的方式，表明调用的是父类中声明的属性。
4.super调用构造器。
    4.1 可以在子类中使用"super(形参列表)"的方式，调用父类中指定的构造器
    4.2 super调用构造器必须声明在子类构造器的首行.
    4.3 类的构造器中，this调用本类构造器和super调用父类构造器，只能有一种
    4.4 子类的构造器中，没有显式使用"super(形参列表)"调用父类构造器，也没有使用"this(形参列表)"
    调用本类的构造器，系统默认使用“super()”调用父类构造器。
    4.5 在类的构造器中，至少有一个构造器使用了“super(形参列表)”，调用父类中的构造器。

三、子类对象实例化的全过程
1.从结果上来看：
    子类继承父类以后，就获取了父类中声明的属性或方法、
    创建子类对象，在堆空间中，就会加载所有父类中声明的属性。
2.从过程上看：
    当通过子类的构造器创建子类对象时，一定会直接或间接地调用其父类的构造器，
    进而调用父类的父类的构造器……，直到调用了java.lang.Object类中空参的构造器为止，
    只因为加载过所有的父类的结构，所以才可以看到内存中有父类中的结构，子类对象才可以考虑进行调用。
>>>虽然创建子类对象时，调用了父类的构造器，但只是创建过一个对象，即new的对象。

 */
public class PersonTest {
    public static void main(String[] args) {
        Student s = new Student("Smith",31,"Computer Science");
        s.eat(); //student eat
        System.out.println("-----------------");
        Person p = new Person();
        p.eat(); //person eat
        System.out.println("-----------------");
        Person p2 = new Student();
        p2.eat(); // student eat
        System.out.println("-----------------");
        s.show();
        System.out.println("-----------------");
    }
}
